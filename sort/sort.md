
# 冒泡排序


**原理**：
    比较两个相邻的元素，将值大的元素交换至右端。
    
**思路**：
	依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。
	然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，将小数放前，大数放后。重复第一趟步骤，直至全部排序完成。
 ```
	N个数字要排序完成，总共进行N-1趟排序，每i趟的排序次数为(N-i)次，所以可以用双重循环语句，外层控制循环多少趟，内层控制每一趟的循环次数，即
		for(int i=1;i<arr.length;i++){
			 for(int j=1;j<arr.length-i;j++){
							//交换位置
				}
         }
 ```
    
**优点**：	
    每进行一次排序，就会少比较一次。因为每进行一趟排序都会找出一个较大值。
    第一趟比较之后，排在最后的一个数一定是最大的一个数，第二趟排序的时候，只需要比较除了最后一个数以外的其他的数，
    同样也能找出一个最大的数排在参与第二趟比较的数后面，第三趟比较的时候，只需要比较除了最后两个数以外的其他的数，
    以此类推……也就是说，没进行一趟比较，每一趟少比较一次，一定程度上减少了算法的量。
    
**时间复杂度**：
    1.如果我们的数据正序，只需要走一趟即可完成排序。所需的比较次数C和记录移动次数M均达到最小值，
      即：Cmin=n-1;Mmin=0;所以，冒泡排序最好的时间复杂度为O(n)。
    2.如果很不幸我们的数据是反序的，则需要进行n-1趟排序。每趟排序要进行n-i次比较(1≤i≤n-1)，
      且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：
      
			
      $$C_{max}= \frac{n(n-1)}{2}=O(n^{2})$$
     
      $$M_{max}= \frac{3n(n-1)}{2}=O(n^{2})$$   
      
当原始序列杂乱无序时，冒泡排序的平均时间复杂度为O(n^2)
综上所述：冒泡排序总的平均时间复杂度为：O(n^2). 空间复杂度为O(n),额外为O(1)
   
# 选择排序

**原理**：
        从未排序序列中找出最小（大）值，放到起始位置。然后从剩余未排序的序列中找出最小（大）值，放到已排序序列的末尾，以此类推，直到所有元素全排序完毕。
        
**思路**
        (1)开始时整个线性表为无序表,有序表为空.
        (2)将无序表的第一个元素A[0]与其后的每个元素A[i] (i=1,2,3…n)作比较, 若A[0]较大,将A[i]交换.最后得到的第一个元素将是整个线性表中最小的元素.这样有序表元素+1,无序表元素-1;
        (3)重复第(2)步,直到无序表长度为0;
```
public static void selection_sort(int[] arr) {
	int i, j, min, temp, len = arr.length;
	for (i = 0; i < len - 1; i++) {
		min = i;//未排序序列中最小数据数组下标
		for (j = i + 1; j < len; j++)//在未排序元素中继续寻找最小元素，并保存其下标
			if (arr[min] > arr[j]){
				min = j;}
		temp = arr[min]; //将最小元素放到已排序序列的末尾
		arr[min] = arr[i];
		arr[i] = temp;
	}
}
```

**优点**
        选择排序主要与数据移动有关。
        简单选择排列与序列的初始排序无关。
        如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上。因此对 n个元素的表进行排序总共进行至多 n-1次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。

**时间复杂度**
      简单选择排列与序列的初始排序无关。假设待排序的序列有 N 个元素，则比较次数永远都是N (N - 1) / 2。但移动次数与序列的初始排序有关。当序列正序时，移动次数最少，为 0。当序列反序时，移动次数最多，为n-1次。
      交换次数比冒泡排序较少，由于交换所需CPU时间比比较所需的CPU时间多，n值较小时，选择排序比冒泡排序快。
      原地操作几乎是选择排序的唯一优点，当空间复杂度要求较高时，可以考虑选择排序；实际适用的场合非常罕见。
      所以，总的时间复杂度为O(N^2),空间复杂度为O(n),额外空间复杂度为O(1)
	


