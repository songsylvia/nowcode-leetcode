
# 冒泡排序


**原理**：
    比较两个相邻的元素，将值大的元素交换至右端。
    
**思路**：
	依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。
	然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，将小数放前，大数放后。重复第一趟步骤，直至全部排序完成。
 ```
	N个数字要排序完成，总共进行N-1趟排序，每i趟的排序次数为(N-i)次，所以可以用双重循环语句，外层控制循环多少趟，内层控制每一趟的循环次数，即
		for(int i=1;i<arr.length;i++){
			 for(int j=1;j<arr.length-i;j++){
							//交换位置
				}
         }
 ```
    
**优点**：	
    每进行一次排序，就会少比较一次。因为每进行一趟排序都会找出一个较大值。
    第一趟比较之后，排在最后的一个数一定是最大的一个数，第二趟排序的时候，只需要比较除了最后一个数以外的其他的数，
    同样也能找出一个最大的数排在参与第二趟比较的数后面，第三趟比较的时候，只需要比较除了最后两个数以外的其他的数，
    以此类推……也就是说，没进行一趟比较，每一趟少比较一次，一定程度上减少了算法的量。
    
**时间复杂度**：
    1.如果我们的数据正序，只需要走一趟即可完成排序。所需的比较次数C和记录移动次数M均达到最小值，
      即：Cmin=n-1;Mmin=0;所以，冒泡排序最好的时间复杂度为O(n)。
    2.如果很不幸我们的数据是反序的，则需要进行n-1趟排序。每趟排序要进行n-i次比较(1≤i≤n-1)，
      且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：
      
			
      $$C_{max}= \frac{n(n-1)}{2}=O(n^{2})$$
     
      $$M_{max}= \frac{3n(n-1)}{2}=O(n^{2})$$   
      
当原始序列杂乱无序时，冒泡排序的平均时间复杂度为O(n^2)
综上所述：冒泡排序总的平均时间复杂度为：O(n^2). 空间复杂度为O(n),额外为O(1)
   
# 选择排序

**原理**：
        从未排序序列中找出最小（大）值，放到起始位置。然后从剩余未排序的序列中找出最小（大）值，放到已排序序列的末尾，以此类推，直到所有元素全排序完毕。
        
**思路**
        (1)开始时整个线性表为无序表,有序表为空.
        (2)将无序表的第一个元素A[0]与其后的每个元素A[i] (i=1,2,3…n)作比较, 若A[0]较大,将A[i]交换.最后得到的第一个元素将是整个线性表中最小的元素.这样有序表元素+1,无序表元素-1;
        (3)重复第(2)步,直到无序表长度为0;
```
public static void selection_sort(int[] arr) {
	int i, j, min, temp, len = arr.length;
	for (i = 0; i < len - 1; i++) {
		min = i;//未排序序列中最小数据数组下标
		for (j = i + 1; j < len; j++)//在未排序元素中继续寻找最小元素，并保存其下标
			if (arr[min] > arr[j]){
				min = j;}
		temp = arr[min]; //将最小元素放到已排序序列的末尾
		arr[min] = arr[i];
		arr[i] = temp;
	}
}
```

**优点**
        选择排序主要与数据移动有关。
        简单选择排列与序列的初始排序无关。
        如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上。因此对 n个元素的表进行排序总共进行至多 n-1次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。

**时间复杂度**
      简单选择排列与序列的初始排序无关。假设待排序的序列有 N 个元素，则比较次数永远都是N (N - 1) / 2。但移动次数与序列的初始排序有关。当序列正序时，移动次数最少，为 0。当序列反序时，移动次数最多，为n-1次。
      交换次数比冒泡排序较少，由于交换所需CPU时间比比较所需的CPU时间多，n值较小时，选择排序比冒泡排序快。
      原地操作几乎是选择排序的唯一优点，当空间复杂度要求较高时，可以考虑选择排序；实际适用的场合非常罕见。
      所以，总的时间复杂度为O(N^2),空间复杂度为O(n),额外空间复杂度为O(1)
	

# 插入排序

**原理**
通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
插入排序包括：直接插入排序、二分插入排序以及希尔排序。

一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：
（1）从第一个元素开始，该元素可以认为已经被排序
（2）取出下一个元素，在已经排序的元素序列中从后向前扫描
（3）如果该元素（已排序）大于新元素，将该元素移到下一位置
（4）重复步骤3，直到找到已排序的元素小于或者等于新元素的位置，将新元素插入到该位置后
（5）重复步骤2~5

**思路**
**直接插入**
把temp与arr[j]比较，得arr[j]>temp,则把j上的元素往后移出位置插入其他元素,j指针继续往前移.

注意[0,i-1]都是有序的。如果待插入元素比arr[i-1]还大则无需再与[i-1]前面的元素进行比较了.
```
public void insert(int[] a)
	{
		for(int i=1;i<a.length;i++)     //n-1此扫描，依次向前插入n-1个元素
		{
			int temp=a[i];       //每趟将a[i]插入到前面的排序子序列中
			int j;
			for(j=i-1;j>=0&&temp<a[j];j--)
			{
				a[j+1]=a[j];  //将前面较大的元素向后移动 ，把比temp大或相等的元素全部往后移动一个位置 
			}
			a[j+1]=temp;      //temp值到达插入位置，把待排序的元素temp插入腾出位置的(j+1)
			
		}
	}
```

在直接插入排序的基础上，如果数据量比较大，为了减少关键码的比较次数，可以使用折半插入来寻找要插入的位置.
```
public static void main(String[] args) {
		int[] a = {23,45,3,6,7,5};
		for (int i = 1; i < a.length; i++) {
			int left = 0 ;
			int right = i-1;
			int temp = a[i];
			while(left<=right){             // 利用折半查找插入位置
				int mid = (left+right)/2;   // 取中点
				if(a[mid]>temp)             // 插入值小于中点值
					right = mid-1;          // 向左缩小区间
				else 
					left = mid+1;           // 向右缩小区间
			}
			// left即为找到的要插入的位置，所以下边的循环将left-(i-1)位置的元素依次向后移动
			for (int j = i-1; j>=left; j--){ 
				a[j+1] = a[j];
			}
				a[left] = temp;    // 将temp插入到left位置
		}
		for (int i : a) {
			System.out.println(i);
		}
	}
```
**二分插入**
折半查找比顺序查找快，所以折半插入排序就平均性能来说比直接插入排序要快，它所需要的关键码比较次数与待排序记录的初始排列无关，仅依赖
与记录个数，比较次数约等于nlogn次。当n较大时，总关键码比较次数比直接插入比较次数的最坏情况（n平方）/4要好很多，但比其最好情况
2（n-1）要差，所以在记录的初始排列已经接近有序时，直接插入排序比折半插入排序执行的关键码比较次数要少。



**优点**


**时间复杂度**

*如果序列本来是排好序的，那么会触发最好情况。这时只需要n-1次比较即可，没有任何元素移动。所以最好情况下时间复杂度是 O(n).

*如果序列是逆序排列的，那么会触发最坏情况。这时每个元素都需要一步一步地挪到序列首部。所以最坏情况下的时间复杂度是 O(n^2).

平均情况下的时间复杂度是 O(n^2)，对于几百个元素仍然是很快速的算法，因为实现简单。所以STL中的qsort都会以插入排序作为快速排序的
补充来处理少量元素.
空间复杂度当然是 O(1) 的，插入排序是采用迭代策略实现的，只用了常数个变量而已.

# 快速排序
**原理**
快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。

步骤为：

从数列中挑出一个元素，称为"基准"（pivot），
重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。
递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。
递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。

**思路**
https://upload.wikimedia.org/wikipedia/commons/thumb/a/af/Quicksort-diagram.svg/200px-Quicksort-diagram.svg.png
**优点**

优点：极快，数据移动少；
缺点：不稳定。

**时间复杂度**
** NOTE **

快速排序是二叉查找树（二叉搜索树）的一个空间最优化版本。不是循序地把数据项插入到一个明确的树中，而是由快速排序组织这些数据项到一个由递归调用所隐含的树中。这两个算法完全地产生相同的比较次数，但是顺序不同。对于排序算法的稳定性指标，原地分区版本的快速排序算法是不稳定的。其他变种是可以通过牺牲性能和空间来维护稳定性的。

快速排序的最直接竞争者是堆排序（Heapsort）。堆排序通常比快速排序稍微慢，但是最坏情况的运行时间总是 {\displaystyle O(n\log n)} {\displaystyle O(n\log n)}。快速排序是经常比较快，除了introsort变化版本外，仍然有最坏情况性能的机会。如果事先知道堆排序将会是需要使用的，那么直接地使用堆排序比等待introsort再切换到它还要快。堆排序也拥有重要的特点，仅使用固定额外的空间（堆排序是原地排序），而即使是最佳的快速排序变化版本也需要 {\displaystyle \Theta (\log n)} {\displaystyle \Theta (\log n)}的空间。然而，堆排序需要有效率的随机存取才能变成可行。

快速排序也与归并排序（Mergesort）竞争，这是另外一种递归排序算法，但有坏情况 {\displaystyle O(n\log n)} {\displaystyle O(n\log n)}运行时间的优势。不像快速排序或堆排序，归并排序是一个稳定排序，且可以轻易地被采用在链表（linked list）和存储在慢速访问媒体上像是磁盘存储或网络连接存储的非常巨大数列。尽管快速排序可以被重新改写使用在链串列上，但是它通常会因为无法随机存取而导致差的基准选择。归并排序的主要缺点，是在最佳情况下需要 {\displaystyle \Omega (n)} {\displaystyle \Omega (n)}额外的空间。


# 归并排序
**原理**

https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F

该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。
**思路**


**递归法（Top-down）**
申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
设定两个指针，最初位置分别为两个已经排序序列的起始位置
比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
重复步骤3直到某一指针到达序列尾
将另一序列剩下的所有元素直接复制到合并序列尾

**迭代法（Bottom-up）**
原理如下（假设序列共有 {\displaystyle n} n个元素）：
将序列每相邻两个数字进行归并操作，形成 {\displaystyle ceil(n/2)} {\displaystyle ceil(n/2)}个序列，排序后每个序列包含两/一个元素
若此时序列数不是1个则将上述序列再次归并，形成 {\displaystyle ceil(n/4)} {\displaystyle ceil(n/4)}个序列，每个序列包含四/三个元素
重复步骤2，直到所有元素排序完毕，即序列数为1

**优点**
优点：归并排序只对相邻的数组元素进行处理，所以相对来说归并排序的速度有可能在某一数据量区域内优于普通快排.
缺点：归并排序占用了大量的内存空间（占用了和原数组等长的空间，一旦待排数组的量非常巨大的话，这完全是致命的缺点）里进行排序操作，所以来说，归并排序在大数据的时候很容易造成内存的溢出。

**时间复杂度**


# 堆排序

**原理**

**思路**

**优点**


**时间复杂度**


# 希尔排序

**原理**

**思路**

**优点**


**时间复杂度**


# 计数排序
**原理**

**思路**

**优点**


**时间复杂度**


# 基数排序
**原理**

**思路**

**优点**


**时间复杂度**

